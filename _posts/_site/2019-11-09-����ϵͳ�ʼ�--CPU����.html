<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

<p>《操作系统概念》 第五章</p>

<h2 id="基本概念">基本概念</h2>

<h3 id="cpu-io-区间周期">CPU-I/O 区间周期</h3>

<p>CPU 的成功调度依赖于：进程执行由 CPU 执行和I/ O等待周期组成，进程在这两个状态之间切换。</p>

<p>CPU 区间的长度已被大量地测试过。I/O 约束程序通常具有很多短CPU 区间。 CPU 约束程序可能有少量的长 CPU 区间。这种分布有助于选择合适的CPU 调度算法。</p>

<h3 id="cpu-调度程序">CPU 调度程序</h3>

<p>每当 CPU 空闲时，操作系统就必须从就绪队列中选择一个进程来执行。进程选择由短期调度程序 (short-term scheduler) 或 CPU 调度程序执行。</p>

<p>就绪队列不必是先进先出 (FIFO) 队列。正如研究各种调度算法时将看到的，就绪队列实现为 FIFO 队列、优先队列、树或简单的无序链表。队列中的记录通常为进程控制块 (PCB) 。</p>

<h3 id="抢占调度">抢占调度</h3>

<p>CPU 调度决策可在如下 4 种环境下发生:</p>

<ul>
  <li>当一个进程从运行状态切换到等待状态(例如， I/O 请求，或等待一个子进程的终止)。</li>
  <li>当一个进程从运行状态切换到就绪状态(例如，当出现中断时)。</li>
  <li>当一个进程从等待状态切换到就绪状态(例如， I/O 完成)。</li>
  <li>当一个进程终止时。</li>
</ul>

<p>当调度只能发生在第 1 和第 4 两种情况下时，称调度方案是非抢占的 (nonpreemptive) 的或协作的 (cooperative) ;否则，称调度方案是抢占的( preemptive)</p>

<h3 id="分派程序">分派程序</h3>

<p>CPU 调度功能有关的另一个部分是分源程序 (dispatcher) 。分派程序是一个模块， 用来将 CPU 的控制交给由短期调度程序选择的进程。其功能包括:</p>

<ul>
  <li>切换上下文。</li>
  <li>切换到用户模式。</li>
  <li>跳转到用户程序的合适位置，以重新启动程序。</li>
</ul>

<p>分派程序停止一个进程而启动另一个所要花的时间称为分报延迟 (dispatch latency)。</p>

<h2 id="调度准则">调度准则</h2>

<ul>
  <li>CPU 使用率:使 CPU 尽可能忙。从概念上讲， CPU 使用率从 0%~100%。对于真实系统，它应从 40% (轻负荷系统) ~90% (重负荷系统)。</li>
  <li>吞吐量:如果 CPU忙于执行进程，那么就有工作在完成。一种测量工作量的方法称为吞吐量，它指一个时间单元内所完成进程的数量。对于长进程，吞吐量可能为每小一个进程；对于短进程，吞吐量可能为每秒 10 个进程。 ·</li>
  <li>周转时间:从进程提交到进程完成的时间段称为周转时间。周转时间为所有时间段之和，包括等待进入内存、在就绪队列中等待、在 CPU 上执行和I/O 执行。</li>
  <li>等待时间: CPU 调度算法并不影响进程运行和执行 I/O 的时间:它只影响进程在就绪队列中等待所花的时间。</li>
  <li>晌应时间:是从提交请求到产生第一响应的时间，这种时间称为晌应时间。是开始响应所需要的时间，而不是输出响应所需要的时间。</li>
</ul>

<h2 id="调度算法">调度算法</h2>

<h3 id="先到先服务调度">先到先服务调度</h3>

<p>显然，最简单的 CPU 调度算法是先到先服务调度算法 (first-come ， first-served (FCFS) Scheduling algorithm)。</p>

<p>先请求CPU 的进程先分配到 CPU。 FCFS 策略可以 用 FIFO 队列来容易地实现。当一个进程进入到就绪队列，其PCB 链接到队列的尾部。当 CPU 空闲时， CPU 分配给位于队列头的进程。</p>

<p>由于所有其他进程都等待一个大进程释放 CPU，与让较短进程最先执行相比，这样会导致 CPU 和设备的使用率变得更低。允许一个进程保持CPU 时间过长将是个严重错误。</p>

<h3 id="最短作业优先调度">最短作业优先调度</h3>

<p>最短作业优先调度算法 (shortest-job-first (SJF) scheduling algorithm) 将每个进程与其下一个 CPU 区间段相关联。当 CPU 为空闲时，它会赋给具有最短下一个 CPU 区间的进程。如果两个进程具有同样长度，那么可以使用 FCFS 调度来处理。</p>

<p>SJF 调度算法可证明为最佳的，这是因为对于给定的一组进程， SJF 算法的平均等待时间最小。SJF 算法的真正困难是如何知道下一个CPU 区间的长度。</p>

<p>一种方法是近似SJF 调度。虽然不知道下一个CPU 区间的长度， 但是可以认为下一个CPU 区间的长度与以前的相似。因此，通过计算下一个CPU区间长度的近似值，能选择具有最短预测CPU 区间的进程来运行。 下一个 CPU 区间通常可预测为以前CPU 区间的测量长度的指数平均。</p>

<p>设 <script type="math/tex">t_n</script> 为第n 个 CPU 区间的长度，设 <script type="math/tex">\tau _{n+1}</script> 为下一个 CPU 区间的预测值。对于<script type="math/tex">\alpha, 0\le \alpha \le 1</script> ，定义</p>

<script type="math/tex; mode=display">\tau _{n+1} = \alpha t_n + (1-\alpha)\tau_n</script>

<p><script type="math/tex">t_n</script> 包括最近信息 ， <script type="math/tex">\tau _n</script> 存储了过去历史。</p>

<p>SJF 算法可能是抢占的或非抢占的。当一个新进程到达就绪队列而以前进程正在执行 时，就需要选择。与当前运行的进程相比，新进程可能有一个更短的 CPU 区间。<strong>抢占 SJF 算法</strong>可抢占当前运行的进程，而<strong>非抢占 SJF 算法</strong>会允许当前运行的进程先完成其 CPU 区间。 抢占 SJF 调度有时称为最短剩余时间优先调度( shortest-remaining-time-first scheduling) 。</p>

<h3 id="优先级调度">优先级调度</h3>

<p>SJF 算法可作为通用优先组调度算法 (priority scheduling algorithm) 的一个特例。每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到 CPU 。具有相同优先级的进程按 FCFS 顺序调度。</p>

<p>优先调度可以是抢占的或者非抢占的。当一个进程到达就绪队列时，其优先级与当前运行进程的优先级相比较。如果新到达进程的优先级高于当前运行进程的优先级，那么<strong>抢占优先级调度算法</strong>会抢占CPU。而<strong>非抢占优先级调度算法</strong>只是将新进程加到就绪队列的头部。</p>

<p>优先级调度算法的一个主要问题是无穷阻塞(indefinite blocking) 或饥饿 (statvation) 。 优先级调度算法会使某个低优先级进程无穷等待 CPU。</p>

<p>低优先级进程无穷等待问题的解决之一是老化 (aging) 。老化是一种技术，以逐渐增加在系统中等待很长时间的进程的优先级。</p>

<h3 id="轮转法调度">轮转法调度</h3>

<p>轮转法 (round-robin， RR) 调度算法是专门为分时系统设计的。它类似于FCFS 调度，但是增加了抢占以切换进程。定义一个较小时间单元，称为时间片 (time quantum， or time slice)。CPU 调度程序循环就绪队列，为每个进程分配不超过一个时间片的CPU。</p>

<p>进程可能只需要小于时间片的CPU 区间。对于这种情况，进程本身会自动释放CPU。调度程序接着处理就绪队列的下一个进程。否则，如果当前运行进程的 CPU 区间比时间片要长，定时器会中断并产生操作系统中断，然后进行上下文切换，将进程加入到就绪队列的尾部，接着CPU 调度程序会选择就绪队列中的下一个进程。</p>

<p>采用RR策略的平均等待时间通常较长。RR 调度算法是可抢占的。</p>

<h3 id="多级队列调度">多级队列调度</h3>

<p>在进程可容易地分成不同组的情况下，可以建立另一类调度算法。例如，一个常用的划分方法是前台(交互)进程和后台(批处理)进程。</p>

<p>多级队列调度算法 (multilevel queue scheduling algorithm) 将就绪队列分成多个独立队列。根据进程的属性，如内存大小、进程优先级、进程类型，一个进程被永久 地分配到一个队列。每个队列有自己的调度算法。</p>

<p>另外，队列之间必须有调度，通常采用固定优先级抢占调度。例如，前台队列可以比后台队列具有绝对的优先级。 可能造成饥饿。</p>

<p>另一种可能是在队列之间划分时间片。每个队列都有一定的 CPU 时间，这可用于调度队列内的进程。</p>

<h3 id="多级反馈队列调度">多级反馈队列调度</h3>

<p>多级反馈队列调度算法 (multilevel feedback queue scheduling algorithm) 允许进程在队列之间移动。如果进程使用过多 CPU 时间，那么它会被转移到更低优先级队列。这种方案将I/O约束和交互进程留在更高优先级队列。此外，在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化阻止饥饿的发生。</p>

<p>通常，多级反馈队列调度程序可由下列参数来定义:</p>

<ul>
  <li>队列数量。</li>
  <li>每个队列的调度算法。</li>
  <li>用以确定何时升级到更高优先级队列的方法。</li>
  <li>用以确定何时降级到更低优先级队列的方法。</li>
  <li>用以确定进程在需要服务时应进入哪个队列的方法。</li>
</ul>

<p>多级反馈队列调度程序的定义使它成为最通用的 CPU 调度算法。它也是最复杂的算法。</p>

<h2 id="多处理器调度">多处理器调度</h2>

<p>如果有多个 CPU ，则负载分配(load sharing) 成为可能，但调度问题也相应地变得更为复杂。主要讨论处理器功能相同(或同构)的系统。</p>

<h3 id="多处理器调度的方法">多处理器调度的方法</h3>

<p>在一个多处理器中， CPU 调度的一种方法是让一个处理器(主服务器)处理所有的调度决定、 I/O 处理以及其他系统活动，其他的处理器只执行用户代码。这种非对称多处理 (asymmetric multiprocessing) 方法更为简单，因为只有一个处理器访问系统数据结构，减轻了数据共享的需要。</p>

<p>另一种方法是使用对称多处理 (symmetric multiprocessing, SMP) 方法，即每个处理器自我调度，通过每个处理器检查共同就绪队列并选择一个进程来执行。必须确保两个处理器不能选择同一进程，且进程不会从队列中丢失。</p>

<h3 id="处理器亲和性">处理器亲和性</h3>

<p>绝大多数 SMP 系统试图避免将进程从一个处理器移至另一个处理器，而是努力使一个进程在同一个处理器上运行，这被称为处理器亲和性，即一个进程需有一种对其运行所在的处理器的亲和性。</p>

<p>当一个操作系统具有设法让一个进程保持在同一个处理器上运行的策略，但不能做任何保证时，则会出现<strong>软亲和性</strong> (soft affinity )。支持<strong>硬亲和性</strong> (hard affinity) 的系统调用允许进程指定它不允许移至其他处理器上。</p>

<h3 id="负载平衡">负载平衡</h3>

<p>负载平衡 (load balancing) 设法将工作负载平均地分配到 SMP 系统中的所有处理器上。值得注意的是，负载平衡通常只是对那些拥有自己私有的可执行进程的处理器而言是必要的。</p>

<p>负载平衡通常有两种方法:push migration和 pull migration。对于 push migration，一个特定的任务周期性地检查每个处理器上的负载，如果发现不平衡，即通过将进程从超载处理器移到(push)空闲或不太忙的处理器，从而平均地分配负载。当空闲处理器从一个忙的处理器上拉取 (pull)一个等待任务时，发生pull migration。 push migration 和 pull migration 不能相互排斥，事实上，在负载平衡系统中它们常被并行地实现。</p>

<h3 id="对称多线程">对称多线程</h3>

<p>另一种方法是提供多个 逻辑(而不是物理的) 处理器来实现。这种方法被称为对称多线程 (SMT)，在 Intel 处理 器中，它也被称为超线程(hyperthreading)技术。</p>

<p>SMT 是硬件而不是软件提供的，硬件应该提供每个逻辑处理器的架构状态的表示以及中断处理方法。操作系统不必被特殊设计，但如果操作系统意识到它是在这样一个系统上运行，它还是可以得到性能的提升。</p>

<h2 id="线程调度">线程调度</h2>

<p>对支持用户线程和内核线程的操作系统而言，系统调度的是内核线程，而不是进程。用户线程由线程库管理，内核并不了解它们。为了能在 CPU 上运行，用户线程最终必须映射到相应的内核级线程，尽管这种映射可能是间接的，可能使用轻量级进程 (LWP)</p>

<h3 id="竞争范围">竞争范围</h3>

<p>用户线程与内核线程的区别之一在于它们是如何被调度的。在执行多对一模型和多对多模型的系统上，线程库调度用户级线程到一个有效的 LWP 上运行，这被称为进程竞争范围 (process-contention scope, PCS) 方法。</p>

<p>为了决定调度哪个内核线程到 CPU，内核采用系统竞争范围 (system-contention scope, SCS) 方法来进行。采用 SCS 调度方法，竞争 CPU 发生在系统的所有线程中.</p>

<p>典型地， PCS 是根据优先级完成的——调度程序选择具有最高优先级的可运行的线程来运行。用户级线程优先级由程序员给定，并且不被线程库调节，尽管有些线程库允许程序员改变线程的优先级。</p>

<h2 id="算法评估">算法评估</h2>

<h3 id="确定模型">确定模型</h3>

<p><strong>分析评估法</strong> (analytic evaluation) 使用给定算法和系统负荷，产生一个公式或数字，以评估对于该负荷算法的性能。</p>

<p><strong>确定模型法</strong> (deterministic modeling) 采用特殊预先确定的负荷，计算在给定负荷下每个算法的性能。</p>

<h3 id="排队模型">排队模型</h3>

<p>计算机系统可描述为服务器网络。每个服务器都有一个等待进程队列。 CPU 是具有就绪队列的服务器，而I/O 系统是具有设备队列的服务器。知道了到达率和服务率，可计算使用率、平均队列长度、平均等待时间等。这种研究称为排队网络分析( queueing-network analysis) 。</p>

<p>$ n $ 为平均队列长度(不包括正在服务的进程)， $W$  为队列的平均等 待时间 ， $ \lambda$ 为新进程到达队列的平均到达率(如每秒三个进程)。Little 公式:</p>

<script type="math/tex; mode=display">n = \lambda \times W</script>

<p>排队分析可用于比较调度算法，但它也有限制。就目前而言，可以处理的算法和分布还是比较有限的。复杂算法或分布的数学分析可能难于处理。队列模型只是现实系统的近似，计算的结果也值得怀疑。</p>

<h3 id="模拟">模拟</h3>

<p>模拟涉及对计算机系统进行建模。</p>

<p>频率分布只表示每个事件发生了多少次，它并不能表示事件的发生顺序。可以采用<strong>跟踪磁带</strong>来解决这个问题。通过监视真实的系统，记录下事件发生的顺序来建立跟踪磁带，然后使用这个顺序来驱动模拟。</p>

<h3 id="实现">实现</h3>

<p>真实算法放入操作系统，然后在真实操作系统内进行评估。该方法的主要困难是其高昂的代价。存在的另一个困难是算法所使用的环境会发生改变。</p>

<p>最为灵活的调度算法可以为系统管理员和用户所改变，以使其能为特定的应用或应用集合所调节。<br />
另一种方法是使用 API 来修改进程或线程的优先级。</p>
