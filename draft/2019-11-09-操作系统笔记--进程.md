---
title: 操作系统笔记--进程
date: 2019-11-09
categories:
- OS
tags:
- 操作系统
typora-copy-images-to: ..\images
---

《操作系统概念》 第三章

## 进程概念

### 进程

进程不只是程序代码，程序代码有时称为文本段(或代码段)。进程还包括**当前活动**，通过程序计数器的值和处理器寄存器的内容来表示。另外，进程通常还包括进程堆栈段(包括临时数据，如函数参数、 返回地址和局部变量)和数据段(包括全局变量)。进程还可能包括堆 (heap) ——在进程运行期间动态分配的内存。

### 进程状态

+ New：进程正在被创建。
+ Running：指令正在被执行。 
+ Waiting：进程等待某个事件的发生(如 νo 完成或收到信号)。 
+ Ready：进程等待分配处理器。
+ Terminated：进程完成执行。

### 进程控制块

每个进程在操作系统内用进程控制块 (process control block. PCB. 也称为任务控制块) 来表示。包含相关信息：

+ 进程状态:状态可包括新的、就绪、运行、等待、停止等。 
+ 进程编号
+ 程序计数器:计数器表示进程要执行的下个指令的地址。
+ CPU 寄存器:根据计算机体系结构的不同，寄存器的数量和类型也不同。它们包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件码信息寄存器。与程序计数器一 起，这些状态信息在出现中断时也需要保存，以便进程以后能正确地继续执行。 
+ CPU 调度信息:这类信息包括进程优先级、调度队列的指针和其他调度参数
+ 内存管理信息:根据操作系统所使用的内存系统，这类信息包括基址和界限寄存器的值、页表或段表。 
+ 记账信息:这类信息包括 CPU 时间、实际使用时间、时间界限、记账数据、进程数量等。 
+ I/O 状态信息:这类信息包括分配给进程的I/O设备列表、打开的文件列表等。 

### 线程

单一控制线程使得进程一次只能执行一个任务。许多现代操作系统扩展了进程概念以支持一次能执行多个线程。

## 进程调度

分时系统的目的是在进程之间快速切换 CPU 以便用户在程序运行时能与其进行交互。为了达到此目的，**进程调度**选择一个可用的进程(可能从多个可用进程集合中选择)到 CPU 上执行。

### 调度队列

进程进入系统时，会被加到**作业队列**中，该队列包括系统中的所有进程。驻留在内存中就绪的、等待运行的进程保存在**就绪队列**中。等待特定I/O 设备的进程列表称为**设备队列**。每个设备都有自己的设备队列。

新进程开始处于就绪队列。它在就绪队列中等待直到被选中执行或被派遣。当进程分配到 CPU 并执行时，可能发生下面事件中的一种:

+ 进程可能发出一个I/O请求，并被放到 I/O 队列中。
+ 进程可能创建一个新的子进程，井等待其结束。
+ 进程可能会由于中断而强制释放 CPU ，并被放回到就绪队列中。

### 调度程序

通常对于批处理系统，进程更多地是被提交，而不是马上执行。这些进程被放到大容 量存储设备(通常为磁盘)的缓冲地中，保存在那里以便以后执行。**长期调度程序**(long-term scheduler) 或作业调度程序 (job scheduler) 从该地中选择进程，并装入内存以准备执行。 **短期调度程序** (short-term scheduler) 或 CPU 调度程序从准备执行的进程中选择进程，并为之分配 CPU。 

短期调度程序必须频繁地为CPU 选择新进程。由于每次执行之间的时间较短，短期调度程序必须要快。

长期调度程序必须仔细选择。通常，绝大多数进程可分为: I/O 为主或 CPU 为主。 为了达到最好性能，系统需要一个合理的I/O为主和 CPU 为主的组合进程。 

有的操作系统如分时系统，可能引入另外的**中期调度程序**( medium-term scheduler) 。中期调度程序的核心思想是能将进程从内存(或从 CPU 竞争)中移出，从而降低多道程序设计的程度。之后，进程能被重新调入内存，并从中断处继续执行。这种方案称为交换 (swapping) 。为了改善进程组合，或者因内存要求的改变引起了可用内存的过度使用而需要释放内存，就有必要使用交换。

### 上下文切换

将 CPU 切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务称为上下文切换 (context switch)。

当发生上下文切换时，内核会将旧进程的状态保存在其 PCB 中，然后装入经调度要执行的并己保存的新进程的上下文。上F文切换时间是额外开销，因为切换时系统并不能做什么有用的工作。

## 进程操作

### 进程创建

进程在其执行过程中，能通过创建进程系统调用 (create-process system call)创建多个新进程。创建进程称为父进程，而新进程称为子进程。每个新进程可以再创建其他进程，从而形成了进程树。

大多数操作系统根据一个唯一的进程标识符 (process identifier, pid)来识别进程， pid 通常是一个整数值。

限制子进程只能使用父进程的资源能防止创建过多的进程带来的系统超载。  
在进程创建时，除了得到各种物理和逻辑资源外，初始化数据(或输入)由父进程传递给子进程。

当进程创建新进程时，有两种执行可能:

+ 父进程与子进程并发执行。 
+ 父进程等待，直到某个或全部子进程执行完。

新进程的地址空间也有两种可能:  

+ 进程是父进程的复制品(具有与父进程相同的程序和数据)。
+ 子进程装入另一个新程序。

### 进程终止

当进程完成执行最后的语句并使用系统调用 exit()请求操作系统删除自身时，进程终止。

在其他情况下也会出现终止。进程通过适当的系统调用能终止另一个进程。通常，只有父进程才能执行这一系统调用。

父进程终止其子进程的原因有很多，如:
+ 子进程使用了超过它所分配到的一些资源。
+ 分配给子进程的任务己不再需要。
+ 父进程退出，如果操作系统不允许父进程终止后子进程继续。

如果操作系统允许父进程终止后子进程继续，父进程终止，那么其所有子进程会以 init 进程作为父进程。因此，子进程仍然有一个父进程来收集状态和执行统计。 

## 进程间通信

操作系统内并发执行的进程可以是独立进程或协作进程。

可能需要提供环境以允许进程协作，这有许多理由

+ 信息共享( infonnation sharing): 由于多个用户可能对同样的信息感兴趣(例如共享的文件)。
+ 提高运算速度( computation speedup): 如果希望一个特定任务快速运行，那么必须将它分成子任务，每个子任务可以与其他子任务并行执行。
+ 模块化( modularity) :可能需要按模块化方式构造系统，将系统功能分成独立进程或线程。
+ 方便 (convenience):单个用户也可能同时执行许多任务。例如，一个用户可以并行进行编辑、打印和编译操作。

进程间通信有两种基本模式   

+ 共享内存， 建立起一块供协作进程共享的内存区域，进程通过向此共享区域读或写入数据来交换信息。
+ 消息传递，通过在协作进程间交换消息来实现通信。

### 共享内存系统

采用共享内存的进程间通信需要通信进程建立共享内存区域。采用共享内存是解决生产者消费者问题方法中的一种。

### 消息传递系统

**命名**：

需要通信的进程必须有一个方法以互相引用。它们可使用直接或间接通信。

对于直接通信，需要通信的每个进程必须明确地命名通信的接收者或发送者。  
直接通信限制了进程定义的模块化。改变进程的名称可能必须检查所有其他进程定义。所有旧名称的引用都必须找到，以便修改成为新名称。

在间接通信中，通过邮箱或端口来发送和接收消息。只有在两个进程共享一个邮箱时，才能建立通信线路。一个线路可以与两个或更多的进程相关联。两个通信进程之间可有多个不同的线路，每个线路对应于一个邮箱。  
操作系统必须提供机制以允许进程进行如下操作:

+ 创建新邮箱。
+ 通过邮箱发送和接收消息。
+ 删除邮箱。

**同步**   

+ 阻塞 send: 发送进程阻塞，直到消息被接收进程或邮箱所接收。
+ 非阻塞 send: 发送进程发送消息并再继续操作。
+ 阻塞 receive: 接收者阻塞，直到有消息可用。
+ 非阻塞 receive: 接收者收到一个有效消息或空消息。 

**缓冲**

不管通信是直接的或是间接的，通信进程所交换的消息都驻留在临时队列中。队列实现有三种方法: 

+ 零容量:队列的最大长度为 0;线路中不能有任何消息处于等待，必须阻塞发送，直到接收者接收到消息。
+ 有限容量:队列的长度为有限的 n; 因此，最多只能有 n 个消息驻留其中。如果在发送新消息时队列未满，那么该消息可以放在队列中，且发送者可继续执行而不必等待。如果线路满，必须阻塞发送者直到队列中的空间可用为止。
+ 无限容量:队列长度可以无限，因此，不管多少消息都可在其中等待，从不阻塞发送者。

 零容量情况称为没有缓冲的消息系统，其他情况称为自动缓忡。 

## 客户机-服务器系统通信 

### Socket

Socket (套接宇)可定义为通信的端点。一对通过网络通信的进程需要使用一对 Socket——每个进程各有一个。 Socket 由 IP 地址与一个端口号连接组成。所有连接必须唯一。

使用 Socket 进行通信，虽然常用和高效，但是它属于较为低级的分布式进程通信。原因之一在于 Socket 只允许在通信线程之间交换无结构的字节流。客户机或服务器程序需要负责加上数据结构

### 远程过程调用  (RPC) 

RPC 设计成抽象过程调用机制，用于通过网络连接系统。
RPC 语义允许客户机调用位于远程主机上的过程，就如同调用本地过程一样。通过在客户端提供存根 (stub)， RPC 系统隐藏了允许通信发生的必要细节。通常，对于每个独立的远程过程都有一个存根。当客户机调用远程过程时，RPC 系统调用合适的存根，并传递远程过程的参数。该存根位于服务器的端口，并编组(marshal)参数。

有一个必须处理的事项是关于如何处理客户机和服务器系统的数据表示的差别。为了处理这一问题， 许多 RPC 系统都定义了数据的机器无关表示。如外部数据表示 (XDR) 。 

另一个重要的事项就是调用的语义。由于普通网络错误， RPC 可能会失败或重复多次执行。处理该问题的一种方法是操作系统确保一个消息刚好执行一次，而不是最多只执行一次。对"刚好一次"，需要消除服务器从未收到请求的风险。为了实现此目的，服务器执行"最多一次"协议，客户机必须周期性重发每个 RPC 调用，直到它接收到对该调用的 ACK。 

另一个重要事项是关于服务器与客户机间的通信问题。第一种方法，绑定信息以固定端口地址形式预先固定。第二种方法，绑定通过集合点机制动态地进行。

### 远程方法调用 (RMI)

 RMI 允许线程调用远程对象的方法。如果对象位于不同的 JVM 上，那么就认为它是远程的。因此，远程可能在同一计算机或通过网络连接的主机的不同 JVM上。

RMI 和 RPC 在两方面有根本的不同。第一， RPC 支持子程序编程，即只能调用远程的子程序或函数； RMI 是基于对象的，它支持调用远程对象的方法。第二，在 RPC 中，远程过程的参数是普通数据结构，而 RMI 可以将对象作为参数传递给远程方法。 RMI 通过允许 Java 程序调用远程对象的方法，使得用户能够开发分布在网络上的 Java 应用程序。 

为了使远程方法对客户机和服务器透明， RMI 采用存根(stub) 和骨干( skeleton) 实 现远程对象。当客户机调用远程方法时，远程对象的存根存根将具有服务器上要调用方法的名称和用于该方法的编排参数的包发送给服务器，远程对象的骨干会接收它。骨干负责重新编排参数并调用服务器上所要执行的方法。骨干接着编排返回值(或异常) ，然后打包，并将该包返回。存根重新编排返回值，并传递给客户机。

