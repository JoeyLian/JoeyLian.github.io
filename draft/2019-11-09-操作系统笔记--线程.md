---
title: 操作系统笔记--线程
date: 2019-11-09
categories:
- OS
tags:
- 操作系统
typora-copy-images-to: ..\images
---

《操作系统概念》 第四章

## 概述

线程是 CPU 使用的基本单元，它由线程 ID、程序计数器、寄存器集合和栈组成成。它与属于同进程的其他线程共享代码段、数据段和其他操作系统资源，如打开文件和信号。

### 动机

一个应用程序通常是作为一个具有多个控制线程的独立进程实现的。一个应用程序可能需要执行多个相似任务。  
一种解决方法是让服务器作为单个进程运行接收请求。当服务收到请求时，会创建另一个进程以处理请求：进程创建很耗时间和资源。

### 优点

+ 晌应度高:如果对一个交互程序采用多线程，那么即使其部分阻塞或执行较冗长的操作，该程序仍能继续执行，从而增加对用户的响应程度。
+ 资源共享:线程默认共享它们所属进程的内存和资源。代码和数据共享的优点是它能允许一个应用程序在同一地址空间有多个不同的活动线程。
+ 经济:进程创建所需要的内存和资源的分配比较昂贵。由于线程能共享它们所属进程的资源，所以创建和切换线程会更为经济。
+ 多处理器体系结构的利用:多线程的优点之→是能充分使用多处理器体系结构， 以便每个进程能并行运行在不同的处理器上。不管有多少 CPU，单线程进程只能运行在一个 CPU 上。在多 CPU 上使用多线程加强了并发功能。 

## 多线程模型

有两种不同方法来提供线程支持：用户层的用户线程或内核层的内核线程。用户线程受内核支持，但不受内核管理。用户线程对程序员来说是可见的，而对内核来说却是未知的。内核线程由操作系统直接支持和管理。

### 多对一模型

多对一模型将许多用户级线程映射到一个内核线程。

线程管理是由线程库在用户空间进行的，因而效率比较高。但是如果一个线程执行了阻塞系统调用，那么整个进程会阻塞。而且，因为任一时刻只有一个线程能访问内核，多个线程不能并行运行在多处理器上。

### 一对一模型

一对一模型将每个用户线程映射到一个内核线程。

该模型在一个线程执行阻塞系统调用时，能允许另一个线程继续执行，所以它提供了比多对一模型更好的并发功能；它也允许多个线程能并行地运行在多处理器系统上。这种模型的缺点是每创建一个用户线程就需要创建一个相应的内核线程。创建内核线程的开销会影响应用程序的性能，所以这种模型的绝大多数实现限制了系统所支持的线程数量。 

### 多对多模型

多对多模型多路复用了许多用户线程到同样数量或更小数量的内核线程上。内核线程的数量可能与特定应用程序或特定机器有关。

多对多模型没有前两者的缺点：开发人员可创建任意多的用户线程，且相应内核线程能在多处理器系统上并发执行。当一个线程执行阻塞系统调用时，内核能调度另一个线程来执行。  
一个流行的多对多模型的变种仍然多路复用了许多用户线程到同样数量或更小数量的内核线程上，但也允许将一个用户线程绑定到某个内核线程上。这个变种有时被称为二级模型。

##  线程库

主要有两种方法来实现线程库。

+ 第一种方法是在用户空间中提供一个没有内核支持的库，此库的所有代码和数据结构都存在于用户空间中。调用库中的一个函数只是导致了用户空间中的一个本地函数调用，而不是系统调用。
+ 第二种方法是执行一个由操作系统直接支持的内核级的库。此时，库的代码和数据结构存在于内核空间中。调用库中的一个 API 函数通常会导致对内核的系统调用。 

### Pthread 

通过函数调用 pthread_create()创建一个独立线程。除了传递线程标识符和线程属性外，还要传递函数名称(这里为 runner() 以便新线程可以开始执行。

### Win32 线程

### Java 线程

在 Java 程序中有两种创建线程的技术。一种方法是创建一个新的类，它从 Thread 类派生，并重载它的 run()函数。另外一种更常使用的方法是定义一个实现 Runnable 接口的类。当一个类执行 Runnable 时，它必须定义 run()函数。而实现 run() 函数的代码被作为二个独 立的线程执行。

作为一个纯面向对象语言， Java 没有全局数据的概念。在 Java 程序中如果两个或更多的线程需要共享数据，通过向相应的线程传递对共享对象的引用来实现

## 多线程问题

### 系统调用 fork()和 exec()

有的 UNIX 系统有两种形式的 fork()，二种复制所有线程，另一种只复制调用了系统调用fork()的线程。 

如果一个线程调用了系统调用 exec() ，那么 exec()参数所指定的程序会替换整个进程，包括所有线程。 

### 取消

**线程取消** (thread cancellation) 是在线程完成之前来终止线程的任务。要取消的线程通常称为目标线程。目标线程的取消可在如下两种情况下发生: 

+ 异步取消 (asynchronous cancellation): 一个线程立即终止目标线程。 
+ 延迟取消 (deferred cancellation): 目标线程不断地检查它是否应终止，这允许目标线程有机会以有序方式来终止自己。如果资源已分配给要取消的线程或要取消的线程正在更新与其他线所共享的数据，取消就会有困难。允许一个线程检查它是否是在安全的点被取消， Pthread 称这些点为取消点 (cancellation point)

### 信号处理

信号用来通知进程某个特定事件已发生了。据需要通知信号的来源和事件的理由，信号可以同步或异步接收。

有信号具有同样模式:

+ 信号是由特定事件的发生所产生的。
+ 产生的信号要发送到进程。
+ 一旦发迭，信号必须加以处理。

单线程程序的信号处理比较直接，信号总是发送给进程。不过，对于多线程程序，发送信号就比较复杂，因为进程可能有多个线程。信号通常有如下选择:

+ 发送信号到信号所应用的线程。
+ 发送信号到进程内的每个线程。
+ 发送信号到进程内的某些固定线程。
+ 规定一个特定线程以接收进程的所有信号。

发送信号的方法依赖于产生信号的类型。

### 线程池 

线程池的主要思想是在进程开始时创建一定数量的线程，并放入到池中以等待工作。当服务器收到请求时，它会唤醒池中的一个线程(如果有可以用的线程)，并将要处理的请求传递给它。一旦线程完成了服务，它会返回到池中再等待工作。如果地中没有可用的线程，那么服务器会一直等待直到有空线程为止。
线程池具有如下主要优点:

+ 通常用现有线程处理请求要比等待创建新的线程要快。
+ 线程池限制了在任何时候可用线程的数量。这对那些不能支持大量并发线程的系统非常重要。

### 线程特定数据

在有些情况下每个线程可能需要一定数据的自己的副本。这种数据称为线程特定数据( thread-specific data)。

### 调度程序激活

多线程编程的最后一个问题是内核与线程库之间的通信问题。许多实现多对多模型或二级模型的系统在用户和内核线程之间设置一种中间数据结构(通常是轻量级进程 (LWP) )。对于用户线程库， LWP 表现为一种应用程序可以调度用户线程来运行的虚拟处理器。每个 LWP 与内核线程相连， 该内核线程被操作系统调度到物理处理器上运行。如果内核线程阻塞(如在等待一个I/ O 操作结束)， LWP 也阻塞。在这个关系链的顶端，与 LWP 相连的用户线程也阻塞。

一种解决用户线程库与内核间通信的方法被称为调度器激活 (scheduler activation) 。内核提供一组虚拟处理器 (LWP) 给应用程序，应用程序可调度用户线程到一个可用的虚拟处理器上。内核告知与应用程序有关的特定事件。 这个过程被称为 upcall。

当一个应用线程将要阻塞时，内核向应用程序发出一个 upcall，通知它线程阻塞井标识特殊的线程。然后内核分配一个新的虚拟处理器给应用程序，应用程序在这个新的虚拟处理器上运行 upcall 处理程序，它保存阻塞线程状态和放弃阻塞线程运行的虚拟处理器。然后 upcall 调度另一个适合在新的虚拟处理器上运行的线程，当阻塞线程事件可以发生时，内核向线程库发出另一个 upcall 来通知它先前阻塞的线程现在可以运行了。

