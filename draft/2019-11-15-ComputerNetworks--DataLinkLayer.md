---
title: ComputerNetworks--DataLinkLayer
date: 2019-11-15
categories:
- CN
tags:
- 计算机网络
typora-copy-images-to: ..\images

---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>



数据链路层的设计原则。涉及两台相邻机器实现可靠有效的完整信息块（称为帧）通信的一些算法，两台机器通过一条通信信道连接起来，通信信道在概念上就像一条线路（比如同轴电缆、电话线或者无线信道）。 通信线路偶尔会出错。只有有限的数据传输率。在比特的发送时间和接收时间之间存在一个非零延迟。 这些限制对数据传输的效率有非常重要的影响。通信所采用的协议必须考虑所有这些因素。 

## 数据链路层的设计问题

数据链路层使用物理层提供的服务在通信信道上发送和接收比特。它要完成一些功能：

1. 向网络层提供一个定义良好的服务接口
2. 处理传输错误
3. 调节数据流，确保慢速的接收方不会被快速的发送方淹没

数据链路层从网络层获得数据包，然后将这些数据包封装成帧 （frame）以便传输。每个帧包含一个帧头、一个有效载荷（用于存放数据包）以及一个帧尾。帧的管理构成了数据链路层工作的核心。

### 提供给网络层的服务

数据链路层的功能是为网络层提供服务。最主要的服务是将数据从源机器的网络层传输到目标机器的网络层。在源机器的网络层有一个实体（称为进程），它将一些比特交给数据链路层，要求传输到目标机器。数据链路层的任务就是将这些比特传输给目标机器。

数据链路层可以设计成向上提供各种不同的服务。实际提供的服务因具体协议的不同而有所差异。一般情况下，数据链路层通常会提供以下 3 种可能的服务：

1. 无确认的无连接服务：源机器向目标机器发送独立的帧，目标机器并不对这些帧进行确认。事先不需要建立逻辑连接，事后也不用释放逻辑连接。数据链路层并不试图去检测丢帧情况，更不会去试图恢复丢失的帧。这类服务合适两种场合，第一种是错误率很低的场合，第二种是实时通信。
2. 有确认的无连接服务。数据链路层没有使用逻辑连接，但其发送的每一帧都需要单独确认。如果一个帧在指定的时间间隔内还没有到达，则发送方将再次发送该帧。802.11 （WiFi）就是 此类服务的一个很好例子。 在可靠信道 上，比如光纤，重量级数据链路协议的开销可能是不必要的：但在无线信道上，由于信道内在的不可靠’性，这种开销还是非常值得的。
3. 有确认的有连接服务。源机器和目标机器在传输任何数据之前要建立一个连接。连接上发送的每一帧都被编号，数据链路层确保发出的每个帧都会真正被接收方收到。还保证每个帧只被接收一次，并且所有的帧都将按正确的顺序被接收。面向连接的服务相当于为网络层进程提供了一个可靠的比特流。

### 成帧

拆分比特流的实际工作比初看上去的要复杂得多。 一个好的设计方案必须使接收方很容易发现一个新帧的开始，使用的信道带宽要少。

1. 字节计数法：第一种成帧方法利用头部中的一个字段来标识该帧中的字符数。当接收方的数据链路层看到字符计数值时，它就知道后面跟着多少个字节， 因此也就知道了该帧在哪里结束。  这个算法的问题在于计数值有可能因为一个传输错误而被弄混。
2. 字节填充的标志字节法：考虑到了出错之后的重新同步问题，它让每个帧用标志字节（flag byte）作为帧的起始和结束分界符。两个连续的标志字节代表了一帧的结束和下一帧的开始。如果接收方丢失了同步，它只需搜索两个标志字节就能找到当前帧的结束和下一帧的开始位置． 然而，还有问题必须要解决。当标志字节出现在数据中时，尤其是当传输二进制数据时会严重干扰到帧的分界。**字节填充**（byte stuffing）：发送方的数据链路层在数据中出现的每个标志字节的前面插入转义字节（ESC）。只要看它数据中标志字节的前面有没有转义字节，就可以把作为帧分界符的标志字节与数据中出现的标志字节区分开来。接收方的数据链路层在将数据传递给网络层之前必须删除转义字节。 如果转义字节也出现在数据中，同样用字节填充技术，即用一个转义字节来填充。在接收方，第一个转义字节被删除，留下紧跟在它后面的数据字节（或许是另一个转义字节或者标志字节）。
3. 比特填充的标志比特法：第三种区分比特流边界的方法考虑了字节填充的缺点，即只能使用 8 比特的字节。 每个帧的开始和结束由一个特殊的比特模式， 01111110 或十六进制 0x7E 标记。这种模式是一个标志字节。每当发送方的数据链路层在数据中遇到连续五个 1，它便自动在输出的比特流中填入一个比特 0。当接收方看到 5 个连续入境比特1紧跟一个比特 0，它就自动剔除比特 0。采用比特填充和字节填充的一个副作用是一帧的长度现在要取决于它所携带的数据内 容。
4. 物理层编码违禁法。 比特编码成信号通常包括一些冗余比特，以便帮助接收器同步接收。例如，在 4B/5B 线性编码模式下， 4 个数据位被映射成 5 个信号比特。这意味着 32 个可能的信号中有 16 个是不会被使用的。我们可以利用这些保留的信号来指示帧的开始和结束。

### 差错控制

确保所有的帧最终都被传递给目标机器的网络层，并且保持正确的顺序。确保可靠传递的常用方法是向发送方提供一些有关线路另一端状况的反馈信息。

一个帧被完全丢失了，接收方根本不会有任何反应：通过在数据链路层中引入计时器来解决。  
当有的帧被发送了多次之后，接收方可能将两次或者多次接收到同一帧，并且多次将它传递给网络层：给发送出去的帧分配序号。

管理好计时器和序号，以便保证每一帧最终都恰好一次地被传递给目标机器的网络层， 这是数据链路层（以及上层）工作的重要组成部分。

### 流量控制

发送方发送帧的速度超过了接收方能够接受这些帧的速度。第一种方法是**基于反馈的流量控制**（feedback-based flow control），接收方给发送方返回信息。第二种方法是**基于速率的流量控制** （rate-based flow control)，使用这种方法的协议有一种内置的机制，它能限制发送方传输数据的速率，而无须利用接收方的反馈信息。 基于速率的方案仅在传输层的一部分中可见，而基于反馈的方案则可同时出现在链路层和更高的层次。

## 差错检测和纠正

针对错误处理两种基本策略：

1. 纠错码（ error-correcting code ）：每一个被发送的数据块中包含足够多的冗余信息，以便接收方能据此推断出被发送的数据是什么。—— 前向纠错（ FEC , Forward Error Correction）
2. 检错码 ( error-detecting code ）：只能让接收方推断出是否发生了错误（而推断不出哪个发生了错误)，请求发送方重传。

错误模型类型：

+ 孤立的单个比特错误。
+ 传输错误呈现突发性而不以单个形式出现 同时还存在着其他类型的错误。
+ 一个错误的位置可以获得，擦除信道（erasure channel)

这些编码方案被广泛使用的根本原因在于可靠性是整个系统所关注的问题。纠错码也会出现在物理层，检错码更是经常被用在链路层、网络层和传输层。 

差错编码是应用的数学。

### 纠错码

一帧由 m 个数据位（即信息）和 r 个冗余余位（即校验）组成。  
在块码 （block code）中， r 个校验位是作为与之相关的 m 个 数据位的函数计算获得的。  
在系统码 ( systematic code）中，直接发送 m 个数据位，然后发出 r 个校验位，而不是在发送前对它们进行编码。  
在线性码 （line code）中， r 个校验位是作为 m 个数据位的线性函数被计算出来的。  
令数据块的总长度为 n （即 n=m+r），我们将此描述为（n, m）码。一个包含了数据位和校验位的 n 位单元称为 n 位码字（codeword）。码率（code rate）定义为码字中不包含元余部分所占的比例，或者用 m/n 表示。

 4 种不同的纠错编码： 

1. 海明码。 

   两个码字中不相同的位的个数称为海明距离（Hamming distance) 。给定计算校验位的算法，可以构建一个完整的合法码字列表，列表中最小海明距离就是整个编码的海明距离。 

   块码的检错和纠错特性跟它的海明距离有关。为了可靠地检测 d 个错误，需要一个距离为 d+1的编码方案。为了纠正 d 个错误，需要一个距离为 2d+1 的编码方案。

   设计一种编码方案，每个码字有 m 个消息位和 r 个校验位，并且能够纠正所有的单个错误。任何一个消息都对应有 n 个非法的码字，它们与该消息的距离为 1。因此，每个消息需要 n+1个位模式来标识它们。
   
$$
(n+1)2^m \le 2^n\\
(m+r+1) \le 2^r   
$$

   给出了纠正单个错误所需要的校验位数的下界。

   在海明码中，码字的位从最左端的位开始依次编号。 2 的幂次方的位是校验位， 其余位填充 m 个数据位。

   **校验位计算：**将个位写成2 的幂次方累加表示，如$11 = 1 + 2 + 8$。偶校验：对第k位上的校验位，使得含有该位因子的位上1的个数为偶数。如第四位上的校验位$p4\oplus m5\oplus m6\oplus m7 = 0$，奇校验则为奇数。

   **校验：**对每组（每个校验位与含有该校验位因子的位组成一组）进行异或，偶校验为0，奇校验为1。若存在不符，出现错误。

   **错误位：**不正确的组为1，正确为0，组成二进制数表示错误位。如校验结果G1 = 1, G2=0，G3=1，G4=0；二进制数为 0b0101 ，第五位出错。

   

   ![image-20191116111408233](\images\image-20191116111408233.png)

2. 二进制卷积码（Binary convolutional code）

   在卷积码中，编码器处理一个输入位序列， 并生成一个输出位序列。输出取决于当前的输入和以前的输入。决定当前输出的以前输入位数称为代码的约束长度（constraint lenth）。卷积码由它们的速率和约束长度来标识。 

   <img src="\images\image-20191116113802975.png" alt="image-20191116113802975" style="zoom:70%;" />

   左边每个输入位产生右边的两个输出位，输出位是输入位和内部状态的 XOR 。处理的是比特位并执行线性运算，因此是二进制的线性卷积码。1 个输入产生 2 个输出，因此码率为 1/2。

   内部状态保存在 6 个内存寄存器中。每当输入一位寄存器的值就右移一位。需要 7 次移位才能完全清空输入，从而不影响输出。该卷积码的约束长度是 k=7。 卷积码的解码过程是针对一个输入位序列，找出最有可能产生观察到的输出位序列（包括任何错误）。对于较小值的 k，逐个检查观察到的序列，记住每一步和输入序列的每个可能内部状态，即输入序列产生观察序列可能产生的错误。最终其中那个具有最少错误的输入序列就是最有可能的消息。 

   卷积码不是简单地将信号绝对映射成逻辑 1 和 0，而是把 0.9V看成 “很可能是 1”，把－0.1 V 看成“很可能是0”，从而最终获得正确的整个序列。 带有一位不确定性的工作方法称为软判决解码（soιdecision decoding）。在执行纠错之前就决定了每个位是 0 或 1 的工作方法称为硬判决解码（hard-decision decoding）。 

3. 里德所罗门码（Reed-Solomon code）

   每一个 n 次多项式是由 n+1点唯一确定的。同一条线上的额外点都是冗余的，这将有助于纠错。 里德所罗门码被定义成一个在有限域上操作的多项式。对于 m 位符号而言，码字长 $2^8 -1$ 个符号。一种流行的选择是 m=8，这样符号就是字节,一个码字为 255 个字节长。（255, 233 ）码被广泛使用，它在 233 个数据符号上增加了 32 个冗余符号。

   里德所罗门码得到广泛应用的原因还在于其强大的纠错性能。 当加入 2t 个冗余符号后，里德所罗门码能够纠正传输符号中的任意 t 个错误。在（255, 233）中，由于有 32 个元余符号，因此可以纠正多达 16 个符号错误。

4. 低密度奇偶校验码（LDPC, Low-Density Parity Check）

    LDPC 码中的每个输出位由一小部分的输入位形成。使得编码可以用一个1的密度很低的矩阵来表示，这也是编码名称的由来。接收到的码字通过一个近似算法解码获得， 该算法通过迭代不断改进接收到的数据与合法码字的最佳匹配。 LDPC 码比较适用于大块数据，而且具有出色的纠错能力。

### 检错码

3 种检错码。这些检错码都是线性的系统块码

1. 奇偶

   把单个奇偶校验位附加到数据中。奇偶位的选择原则是使得码字中比特 1 的数目是偶数（或奇数）。

   交错校验是一种将检测（或纠正）单个错误的编码转换成能检测（或纠正）突发错误的通用技术。当发生一个长度为 n=7 的突发错误，出错的位恰好分散在不同的列。 n 列中的每一列至多只有一位受到影响，因此这些列中的校验位将能检测到该错误。这种方法对于 nk 长度的数据块使用了 n 个校验位就能检测出一个长度小于等于 n 的突发错误。 

2. 校验和（checksum）

   用来指与信息相关的一组校验位，一组奇偶校验位是校验和的一个例子。

3. 循环元余校验 （CRC,Cyclic Redundancy Check,多项式编码（polynomial code））

   将位串看成是系数为 0 或 1 的多项式。加法和减法都等同于异或。发送方和接收方预先商定一个生成多项式 ()generator polynomial) 生成多项式的最高位和最低位系数必须是1。 假设一帧有 m 位，该帧必须比生成多项式长。基本思想是在帧的尾部附加一个校验和，使得附加之后的帧所对应的多项式能够被 G(x）除尽。当接收方收到了带校 验和的帧之后，它试着用 G(x）去除它。如果有余数的话，则表明传输过程中有错误。 

   计算 CRC 的算法如下：

   1. 假设 G(x）的阶为 r。在帧的低位端加上 r 个 0 位， 使得该帧现在包含 m+r 位
   2. 利用模 2 除法，用对应于 G(x）的位串去除对应m+r位的位串
   3. 利用模2减法，从对应m+r位的位串中减去余数（总是小于等于r位）。结果就是将被传输的带校验和的帧。

## 基本数据链路层协议

有关底层通信模型的基本假设：

+ 假设物理层、数据链路层和网络层都是独立的进程
+ 机器 A 希望用一个可靠的、面向连接的服务向机器 B 发送一个长数据流。
+ 机器不会崩溃：只处理通信错误，不处理因为机器崩 溃和重新启动而引起的问题。 

一个帧由 4 个字段组成： kind、 seq、 ack 和 info，其中前 3 个包含了控制信息，最后 一个可能包含了要被传输的实际数据。这些控制宇段合起来称为帧头（frame header）。 

`wait for event ` 是一个严格的循环过程，它等待事情发生。  
`to_network_ layer ` 和 `from_network _layer` 被数据链路层用来向网络层传递数据包或者从网络层接收数据包。  
`from_physical_layer` 和 `to_physical_ layer` 在数据 链路层和物理层之间传递帧。

### 乌托邦式的单工协议

数据只能单向传输。发送方和接收方的网络层总是处于准备就绪状态。数据处理的时间忽略不计。可用的缓存空间无穷大。数据链路层之间的通信信道永远不会损坏帧或者丢失帧。

协议由两个单独的过程组成一个发送过程和一个接收过程。  
发送过程是一个无限的 while 循环，它尽可能快速地把数据放到线路上。循环体由三个动作组成：从网络层获取一个数据包、利用变量 s 构造一个出境帧，然后通过物理层发送该帧。  
接收过程同样很简单。开始时，它等待某些事情的发生，到达了一个帧后，过程 `wait for_ event` 返回。调用`from_physical_ layer` 将新到达的帧从硬件缓冲区中删除，并且放到变量 r 中，以便接收方的代码可以访问该帧。最后，该帧的数据部分被传递给网络层，数据链路层返回继续等待下一帧的到来。

### 无错信道上的单工停－等式协议

处理发送方以高于接收方能处理到达帧的速度发送帧，导致接收方被淹没的问题：

一般化解决方案是让接收方给发送方提供反馈信息。接收方将数据包传递给网络层之后给发送方返回一个小的哑帧，给发送方一个许可允许它发送下一帧。发送方在发出一帧之后，等待一段时间直到短哑帧（即确认）到达。这种延缓就是流量控制协议的一个简单例子。 这样的协议称为停－等式协议 (stop-and-wait）。

### 有错信道上的单工停－等式协议

通信信道可能会出错。帧可能会被损坏，也可能完全被丢失。

一位序号 （0 或者 1) 就足以解决问题。在任何一个时刻，接收方期望下一个特定的序号。当包含正确序号的帧到来时，它被接受下来并且被传递给网络层。然后，接收方期待的下一个的序号 0 变成 1, 1 变成 0。

发送方在送出一帧并启动了计时器后，它就等待着相关事情的发生。此时只有 3 种可能的情况：

+ 确认帧完好无损地返回：发送方从它的网络层获取下一个数据包，并把它放入缓冲区覆盖掉原来的数据包，递增帧的序号
+ 确认帧受到损伤：缓冲区和序号都不作任何改变，以便重传原来的帧。
+ 计时器超时：同上

当一个有效帧到达接收方时，接收方首先检查它的序号，确定是否为重复数据包。如果不是，则接受该数据包并将它传递给网络层，然后生成二个确认帧。重复帧和受损帧的到来会导致最后一个正确接收到的数据帧的确认被重复发送，返回给发送方，发送方做出前进到下一帧或重发那个受损帧的决策。

## 滑动窗口协议

捎带确认（piggybacking）：暂时延缓确认以便将确认信息搭载在下一个出境数据帧上的技术。 

滑动窗口 （sliding window）的协议：任何一个出境帧都包含一个序号， 范围从 0 到某个最大值。序号的最大值通常是 $2^n-1$ ，这样序号正好可以填入到一个 n 位的字段中。停-等式滑动窗口协议使用 n=1，限制了序号只能是 0 和 1 ，但是更加复杂的协议版本可以使用任意的n。

所有滑动窗口协议的本质是在任何时刻发送方总是维持着一个发送窗口（sending window）它发送的帧落在内，接收方维持着一个接收窗口（receiving window）

发送方窗口内的序号代表了那些可以被发送的帧，或者那些已经被发送但还没有被确认的帧。任何时候当有新的数据包从网络层到来时，它被赋予窗口中的下一个最高序号， 并且窗口的上边界前移一格。当收到一个确认时，窗口的下边界也前移一格。按照这种方法发送窗口持续地维持了一系列未被确认的帧。

发送方必须在内存中保存所有这些帧，以便满足可能的重传需要。如果窗口在某个时候达到了它的最 大尺寸，则发送方的数据链路层必须强行关闭网络层，直到有一个缓冲区空闲出来为止。 

接收方数据链路层的窗口对应于它可以接受的帧。任何落在窗口内的帧被放入接收方的缓冲区。 当收到一个帧，而且其序号等于窗口下边界时，接收方将它传递给网络层，并将整个窗口向前移动 1 个位置。

![image-20191116134641942](\images\image-20191116134641942.png)

### 1 位滑动窗口协议

窗口尺寸为 1 的滑动窗口协议：发送方在发出一帧以后， 必须等待前一帧的确认到来才能发送下一帧，所以这样的协议使用了停 - 等式办法。 

然而，如果A 和 B 同时发起通信，则它们的第一帧就会交错，即使没有传输错误，也会有一半的帧是重复的。如果发生多个过早超时，则每一帧都有可能被发送三次或者更多次，严重浪费了宝贵带宽。

![image-20191116135354906](\images\image-20191116135354906.png)

允许发送方在阻塞之前发送多达 w 个帧，而不是一个帧。发送窗口被填满之前前面帧的确认就返回可以防止 了发送方进入阻塞。 

一帧从发送方传播到接收方期间信道上能容纳帧的容量由比特／秒的带宽乘以单向传送时间所决定，或数据链路层有责任 以链路的带宽·延迟乘积（bandwidth-delay product）序列把数据包传递给网络层。这个数量用帧的数量来表示称为 BD。 w 设置为 2BD+1：如果考虑发送方连续发送帧并且在往返时间内收到一个确认，两倍的带宽－延时就是发送方可以连续发送的帧的个数；“＋1 ”是因为必须接收完整个帧之后确认帧才会被发出。

对于较小尺寸的窗口，链路利用率表示发送方未被阻塞的时间比例： 

$$链路利用率\le \frac{W}{1+2BD}$$

保持多个帧同时在传送的技术是管道化（pipelining）的一个例子。

有两种基本办法可用来处理管道化传输中出现的错误。这两种方法是带宽使用效率和数据链路层缓存空间之间的权衡。

### 回退 N 协议

![image-20191116141300887](\images\image-20191116141300887.png)

**回退 n (go-back-n）**，接收方只需简单丢弃所有到达的后续帧，而且针对这些丢弃的帧不返回确认。这种策略对应于**接收窗口**大小为 1 的情形。除了数据链路层必须要递交给网络层的下一帧以外，它拒绝接受任何帧。发送方将超时，并且按照顺序重传从那个受损或者被丢失的帧开始所有的帧。如果信道的错误率很高，这种方法会浪费大量的带宽。 

未确认帧的最大数目必须限制为不能超过 MAX_SEQ（$2^n-1$)。当 n 号帧的确认到达， n-1 号帧、 n-2 号帧等都会自动被确认。这种类型的确认称为累计确认（cumulative acknowledgement）。 当先前一些捎带确认的帧被丢失或者受损之后，这个特性显得尤为重要。

### 选择重传协议

![image-20191116141447234](\images\image-20191116141447234.png)

**选择重传（ selective repeat）**：接收方将收到的坏帧丢弃，但接受并缓存坏帧后面的所有好帧。 当发送方超时，它只重传那个最早的未被确认的帧。如果该重传的帧正确到达接收方，接收方就可按序将它缓存的所有帧递交给网络层。选择重传对应的接收方窗口大于 1 。

接收方为其窗口内的每个序号保留一个缓冲区。与每个缓冲区相关联的还有一个标志位（arrived), 指明该缓冲区是满的还是空的。每当到达一帧，接收方检查它的序号，看是否落在窗口内。如果确实落在窗口内，并且以前没有接收过该帧，则接受该帧， 并且保存在缓冲区。不管这帧是否包含了网络层所期望的下一个数据包。该帧只能被保存在数据链路层中，直到所有序号比它小的那些帧都己经按序递交给网络层之后，它才能被传递给网络层。

当接收方向前移动它的窗口后，新的有效序号范围与老的序号范围有重叠。后续的一批帧可能是重复的帧（如果所有的确认都丢失了)，也可能是新的帧（如果所有的确认都接收到了）：确保接收方向前移动窗口之后，新窗口与老窗口的序号没有重 叠。窗口的最大尺寸应该不超过序号空间的一半，窗口尺寸为 （MAX_SEQ+1) /2。（$2^{n-1}$)

选择重传策略通常跟否定策略结合起来一起使用，即当接收方检测到错误，它就发送一个否定确认（NAK., negative acknowledgement）。 NAK 可以触发该帧的重传操作，而不需要等到相应的计时器超时。

## 数据链路协议实例

点到点协议（PPP, Point-to-Point Protocol) 的标准协议使用这些链路来发送数据包。 

### SONET 上的数据包

PPP 功能包括处理错误检测链路的配置、支持多种协议、允许身份认证等。PPP 提供了 3 个主要特性：

+ 一种成帧方法。它可以毫无歧义地区分出一帧的结束和下一帧的开始
+ 一个链路控制协议，它可用于启动线路、测试线路、协商参数， 以及当线路不再需要时温和地关闭线路。该协议称为链路控制协议 （LCP, Link Control Protocol）。
+ 一种协商网络层选项的方式。协商方式独立于网络层协议，针对每一种支持的网络层都有一个不同的网络控制协议 （NCP, Network Control Protocol) 。 

PPP 帧格式类似 HDLC 帧格式。 HDLC 是一个早期被广泛使用的家庭协议实例。 PPP 和 HDLC 之间的主要区别在于： PPP 是面向字节而不是面向比特的，特别是 PPP 使用字节填充技术， HDLC 协议则使用比特填充技术。第二个主要区别是HDLC 协议提供了可靠的数据传输，PPP 也可以提供可靠传输，但几乎都是采用“无编号模式”来提供无连接无确认的服务。

从标准的 HDLC 标志字节 0x7E(01111110) 开始．标志字节如果出现在 Payload字段，则要用转义字节 0x7D 去填充：然后将紧跟在后面的那个字节与 0x20进行XOR操作，使得第 6位比特反转。0x7D 0x5E 是标志字节 0x7E 的转义序列。

标记字节后面出现的是 Address （地址）字段。这个字段总是被设置为 二进制值 11111111 ，表示所有站点都应该接受该帧。 

Address 字段后面是 Control （控制）字段，其默认值是 00000011 。此值表示一个无编号帧。

第四个字段是 Protocol （协议）字段：通告 Payload 字段中包含了什 么类型的数据包。以 0 开始的编码定义为 IP 版本 4、 IP 版本 6 以及其他可能用到的网络层协议，比如 IPX 和 AppleTalk。以 1 开始的编码被用于 PPP 配置协议，包括 LCP 和针对每个网络层协议而设置的不同 NCP。Protocol 字段的默认大小为 2 个字节，但它可以通过LCP 协商减少到 1 个字节。

Payload （有效载荷）字段是可变长度的，最高可达某个协商的最大值。

后是 Checksum （校验和）字段，它通常占 2 个字节，但可以协商使用 4 个字节的校验和。事实上， 4 字节的校验和与 32 位的 CRC 相同。

![image-20191116144042198](\images\image-20191116144042198.png)

在通过 SONET 线路发送 PPP 帧之前，必须建立和配置 PPP 链路。

![image-20191116145151739](\images\image-20191116145151739.png)

链路的初始状态为 DEAD （死），这意味着不存在物理层连接。  
当物理连接被建立起来， 链路转移到 ESTABLISH （建立）状态。此时， PPP 对等实体交换一系列的 LCP 报文进行选项的协商，这些 LCP 报文放在 PPP 帧的 Payload 字段。   
如果 LCP 选项协商成功，链路状态进入 AUTHENTICATE （认证）状态。双方可以互相检查对方的身份。  
如果认证成功，则链路进入 NETWORK （网络）状态，通过发送一系列的 NCP 包来配置网络层参数。  
一旦进入 OPEN （打开）状态，双方就可以进行数据传输。正是在这个状态下， IP 数 据包被承载在 PPP 帧中通过 SONET 线路传输。  
当完成数据传输后，链路进入TERMINATE （终止）状态：当物理层连接被舍弃后回到 DEAD 状态

### 对称数字用户线

ADSL 链路之上的协议底部是 ADSL 物理层。它们基于称为正交频分复用（也称为离散多音〉的数字调制方案，位于 IP 网络层正下方的是 PPP。异步传输模式（ATM, Asynchronous Transfer Mode）是一种链路层，它的传输基于固定长度的信息信元 （cell）。其名称中的“异步” 意味着这些信元并不总是以连续的方式发送。 只有当出现需要运载的信息时，才发送信元。 ATM 是一种面向连接的技术。

![image-20191116145620483](\images\image-20191116145620483.png)

为了在 ATM 网络上发送数据，需要将数据映射成一系列的信元。这个映射由 ATM 适配层完成，映射过程称为分段（segmentation）和重组（reassembly）。主要用于数据包数据的适配层是 ATM 适应层 5（ AAL5, ATM Adaptation Layer 5）。 

![image-20191116150102752](\images\image-20191116150102752.png)

一个 AALS 帧除了帧头，它还有一个帧尾，给出了帧的长度和用于错误检测的 4 字节 CRC。除了有效载荷外， AAL5 帧还需要被填充。使得帧的总长度是 48 字节的倍数，以便帧被均匀地划分成多个信元。





