---
title: 操作系统笔记--操作系统结构
date: 2019-11-09
categories:
- OS
tags:
- 操作系统
typora-copy-images-to: ..\images
---

《操作系统概念》 第二章

## 操作系统服务

一组操作系统服务提供对用户有用的函数:

**用户界面** : 一种是命令行界面 (command-line interface. CLI)，它采用文本命令，并用一定的方法输入。另一种是批界面，控制这些命令和命令的指令被输入文件中，通过执行文件来实现。最为常用的是图形用户界面。

**程序执行** : 系统必须能将程序装入内存并运行程序。程序必须能结束执行，包括正常或不正常结束(指明错误)。

**I/O 操作**: 为了提高效率和进行保护，用户通常不能直接控制I/O设备。操作系统必须提供进行I/O操作的方法。 

**文件系统操作**: 程序需要读写文件和目录，也需要根据文件名来创建和删除文件、搜索一个给定的文件、列出文件信息

**通信**: 通信可以通过共享内存在来实现，也可通过消息交换技术来实现

**错误检测**: 操作系统需要知道可能出现的错误。错误可能发生在 CPU 或内存硬件、I/O 设备和用户程序中。

另一组操作系统函数，确保系统本身高效运行。多用户系统通过共享计算机资源可以提高效率。

**资源分配**: 同时有多个用户或多个作业运行时，系统必须为它们中的每一个分配资源。

**统计**:需要记录哪些用户使用了多少和什么类型的资源。

**保护和安全**:  保护即确保所有对系统资源的访问是受控的。系统安全不受外界侵犯也很重要。

## 操伟系统的用户界面

### 命令解释程序 

有的操作系统在其内核部分包含命令解释程序。其他操作系统将命令解释程序作为一个特殊程序，当一个任务开始时或用户首次登录时(分时系统) ，该程序就会运行。

命令解释程序的主要作用是获取并执行用户指定的下一条命令。执行这些命令有两种常用的方法。  

+ 一种方法是命令解释程序本身包含代码以执行这些命令。对于这种方法，所能提供的命令的数量决定了命令解释程序的大小，这是因为每个程序需要它自己实现代码。  
+ 另一种方法由系统程序实现绝大多数命令。命令解释程序不必理解什么命令，它只要用命令来识别文件以装入内存并执行

### 图形用户界面

与操作系统交互的第二种方法是采取友好的用户图形界面 (GUI)。与用户通过命令行直接输入命令不同， GUI 允许提供基于鼠标的窗口和菜单系统作为接口。

##  系统调用

**系统调用** (system call)提供了操作系统提供的有效服务界面。

一般应用程序开发人员不需要知道如何执行系统调用或者执行过程中它做了什么，而是根据应用程序接口 (API)设计程序。 API 是一系列适用于应用程序员的函数，包括传递给每个函数的参数及其返回的程序员想得到的值。

绝大多数程序设计语言的运行时支持系统(与编译器一起的预先构造的函数库)提供了系统调用接口，作为应用程序与操作系统的系统调用的链接。系统调用接口截取 API 的 函数调用，并调用操作系统中相应的系统调用。

## 系统调用类型

![image-20191109123728021](\images\image-20191109123728021.png)



## 系统程序

系统程序提供了一个方便的环境，以开发程序和执行程序。其中一小部分只是系统调用的简单接口，其他的可能是相当复杂的。它们可分为如下几类:

**文件管理:**这些程序创建、删除、复制、重新命名、打印、转储、列出和操作文件和目录。  
**状态信息:**一些程序从系统那里得到日期、时间、可用内存或磁盘空间的数量、用户数或类似状态信息。另一些更为复杂，能提供详细的性能、登录和调试信息。  
**文件修改:**有多个编辑器可以创建和修改位于磁盘或其他存储设备上的文件内容。  
**程序语言支持:**常用程序设计语言(如 C、 C++、 Java、 Visual Basic 和 Perl 等)的编译程序、汇编程序、调试程序和解释程序通常与操作系统一起提供给用户。  
**程序装入和执行:**一旦程序汇编或编译后，它必须装入内存才能执行。系统可能要提供绝对加载程序、重定位加载程序、链接编辑器和覆盖式加载程序。系统还需要有高级语言或机器语言的调试程序。  
**通信:**这些程序提供了在进程、用户和计算机系统之间创建虚拟连接的机制。  

## 操作系统设计和实现

### 设计目标

操作系统的规格和设计属于高度创造性工作。

### 机制与策略

一个重要原理是**策略** (policy) 和**机制** (mechanism) 的区分。机制决定如何做，策略决定做什么。

### 实现

现在操作系统都是用高级语言如 C 或 C++来编写的：代码编写更快，更为紧凑，更容易理解和调试。用高级语言来实现操作系统的缺点在于降低了速度和增加了存储要求。

与其他系统一样，操作系统的重要性能改善很可能是由于更好的数据结构和算法。为了识别瓶颈，必须要能监视系统性能。对有的系统，操作系统通过生成系统行为的跟踪列表来执行这一任务。

## 操作系统结构

###  简单结构

在 MS-DOS 系统中，并没有很好地区分接口和功能层次。这种任意性使 MS-DOS 易受错误(或恶意)程序的伤害，从而导致用户程序出错时整个系统的崩溃。

另-个受限结构的例子是原始的 UNIX 操作系统。 由内核和系统程序两个独立部分组成。内核进一步分成为一系列接口和驱动程序，这些程序被不断地增加和扩展，组合了大量的功能。

### 分层方法

系统模块化有许多方法。一种方法是分层法，即操作系统分成若干层(级)。最底层(层 0) 为硬件，最高层(层 N) 为用户接口。

分层法的主要优点在于构造和调试的简单化。每层只能利用较低层的功能和服务，这种方法简化了调试和系统验证。此外，每层为较高层隐藏了一定的数据结构、操作和硬件的存在。

分层法的主要困难涉及对层的详细定义。分层法实现的另一个问题是与其他方法相比其效率稍差。

### 微内核

采用微内核 (microkemel)技术来模块化内核。这种方法将所有非基本部分从内核中移走，并将它们实现为系统程序或用户程序。微内核通常包括最小的进程和内存管理以及通信功能。  

微内核的主要功能是使客户程序和运行在用户空间的各种服务之间进行通信。通信以消息传递形式提供。

微内核方法的好处之一在于便于扩充操作系统。很容易从一种硬件平台设计移植到另一种硬件平台设计。由于绝大多数服务是作为用户而不是作为内核进程来运行的，因此微内核也就提供了更好的安全性和可靠性。

微内核必须忍受由于系统功能总开销的增加而导致系统性能的下降。

### 模块

允许内核提供核心服务，也能动态地实现特定的功能。进一步讲，这种方法类似于微内核方法，核心模块只有核心功能以及其他模块加载和通信的相关信息，但这种方法更为高效，因为模块不需要调用消息传递来通信。 

## 虚拟机

虚拟机的基本思想是单个计算机 (CPU 、内存、磁盘、网卡等)的硬件抽象为几个不同的执行部件，从而造成一种"幻觉"，
仿佛每个独立的执行环境都在自己的计算机上运行一样。

虚拟机方法的主要困难与磁盘系统有关。

### 实现

当一个以虚拟用户模式而在虚拟机上运行的程序执行系统调用时，它会在真实机器上引起一个到虚拟机监控器的转换。当虚拟机监控器获得控制，它能改变虚拟机的寄存器内容和程序计数器以模拟系统调用的效果。

### 优点

+ 不同的系统资源具有完全的保护。
+ 虚拟机系统是用于研究和开发操作系统的好工具。

### 实例

VMware作为一种应用程序运行在主操作系统如Windows或 Linux 之上，并允许主操作系统将几个不同的客户操作系统作为独立的虚拟机来并行地运行

JVM：除了其语言规范和大量API 库， 对于每个 Java 类， Java 编译器会生成与平台无关的字节码 (bytecode) 输出文件( .class ) ，它可运行在任何 JVM 上。

.NET包含了类库集合、执行环境和软件开发平台的技术。这个平台允许基于.NET框架编程而不是针对任何特定平台。任何实现.NET的结构都可以成功执行.NET 程序。这是因为运行环境对这些细节进行了抽象，提供一个介于底层体系结构和被运行的程序之间的虚拟机。

## 系统生成

首先确定信息，接着可以有多种方法来使用信息。

+ 对一种极端情况，系统管理员可用这些信息来修改操作系统的源代码副本。接着完全重新编译操作系统。数据说明、初始化、常量和其他一些条件编译，生成了专门适用于所描述系统的操作系统的目标代码。  
+ 对于另外一种稍微定制过的层，系统描述可用来创建表，并从预先编译过的库中选择模块。这些表格连接起来以形成所生成的操作系统。选择允许库包括所有支持I/O 设备的驱动程序，但是只有所需要的才连接到操作系统。  
+ 对于另外一种极端情况，可以构造完全由表驱动的系统。所有代码都是系统的组成部分，选择发生在执行时而不是在编译或连接时。*绝大多数现代操作系统按这种方式来构造。*

## 系统启动

装入内核以启动计算机的过程称为引导系统。绝大多数计算机系统都有一小块代码，它称为引导程序或引导装载程序。这段代码能定位内核，将它装入内存，开始执行。

通常，一个任务要运行诊断程序来确定机器的状态。 如果诊断通过，程序可按启动步骤继续进行。系统的所有部分都可以被初始化。

有些系统在 ROM 中保存完整的操作系统。对大型操作系统或经常改变的系统，引导程序被存储在固件中，而操作系统保存在磁盘上。引导程序运行诊断程序，它能够从磁盘固定位置 (0 区块)读取整块信息到内存，并从引导块执行代码。